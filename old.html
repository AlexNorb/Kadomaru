<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Card Clicker Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap");

      /* CSS Variables for Dark Mode (Default) */
      :root {
        --bg-primary: #1a202c;
        --bg-secondary: #2d3748;
        --text-color: #e2e8f0;
        --border-color: #4a5568;
        --card-bg-color: #63b3ed;
        --card-shadow: rgba(0, 0, 0, 0.5);
        --button-bg: #48bb78;
        --button-hover-bg: #38a169;
        --button-shadow: rgba(72, 187, 120, 0.4);
        --game-over-text: #f56565;
        --title-color: #f6ad55;
        --level-up-color: #a3e635;
        --emoji-color: #e2e8f0;
        --switch-bg-off: #ccc;
        --switch-bg-on: #48bb78;
        --social-icon-color: #e2e8f0;
        --social-icon-hover: #f6ad55;
        --particle-color: #ffd700; /* Gold/Yellow for particles */
        --bonus-particle-color: #ff0000; /* Red for bonus particles */
        --special-card-glow: rgba(
          255,
          215,
          0,
          0.7
        ); /* Gold glow for special card */
        --boss-card-glow: rgba(
          139,
          0,
          0,
          0.8
        ); /* Dark Red glow for boss card */
      }

      /* CSS Variables for Light Mode */
      body.light-mode {
        --bg-primary: #f0f2f5;
        --bg-secondary: #ffffff;
        --text-color: #2d3748;
        --border-color: #cbd5e0;
        --card-bg-color: #a7d9f7;
        --card-shadow: rgba(0, 0, 0, 0.15);
        --button-bg: #38a169;
        --button-hover-bg: #2f855a;
        --button-shadow: rgba(56, 161, 105, 0.3);
        --game-over-text: #e53e3e;
        --title-color: #d97706;
        --level-up-color: #10b981;
        --emoji-color: #2d3748;
        --switch-bg-off: #a0aec0;
        --switch-bg-on: #38a169;
        --social-icon-color: #2d3748;
        --social-icon-hover: #d97706;
        --particle-color: #ffbf00; /* Slightly darker yellow for particles */
        --bonus-particle-color: #e53e3e; /* Red for bonus particles in light mode */
        --special-card-glow: rgba(
          218,
          165,
          32,
          0.6
        ); /* Darker Gold glow for special card in light mode */
        --boss-card-glow: rgba(
          178,
          34,
          34,
          0.6
        ); /* Medium Red glow for boss card */
      }

      body {
        font-family: "Inter", sans-serif;
        display: flex;
        flex-direction: column; /* Stacks title and main game area vertically */
        justify-content: space-between; /* Aligns content to the top */
        align-items: center; /* Centers content horizontally */
        height: 100dvh; /* Use dynamic viewport height */
        background-color: var(--bg-primary);
        color: var(--text-color);
        overflow: hidden; /* Prevents body scrollbars */
        margin: 0;
        padding: 20px; /* Consistent padding around the content */
        box-sizing: border-box;
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      #game-title {
        font-size: 3rem;
        font-weight: bold;
        color: var(--title-color);
        margin-bottom: 30px;
        text-shadow: 0 0 10px rgba(246, 173, 85, 0.6);
        text-align: center;
        transition: color 0.3s ease;
        flex-shrink: 0; /* Prevents title from shrinking */
      }

      /* New wrapper for stats and game container */
      #main-game-area {
        display: flex;
        flex-direction: column; /* Default: stacks stats and game container vertically */
        align-items: center; /* Centers children horizontally */
        flex-grow: 1; /* Allows it to grow to fill remaining vertical space in body */
        width: 100%; /* Takes full width on mobile */
        max-width: 1200px; /* Limits overall width */
        justify-content: center; /* Centers content vertically within this area */
        gap: 20px; /* Space between stats and game container on mobile */
        min-height: 0;
      }

      #game-container {
        position: relative;
        width: 90vw; /* Default width for mobile */
        max-width: 1200px; /* Max width for mobile */
        flex-grow: 1; /* Allows it to grow to fill available vertical space */
        flex-shrink: 1; /* Allows it to shrink if needed */
        max-height: 100%; /* Ensures it doesn't overflow its flex parent */
        background-color: var(--bg-secondary);
        border-radius: 12px;
        box-shadow: 0 10px 20px var(--card-shadow);
        overflow: hidden; /* Keep cards within bounds */
        border: 2px solid var(--border-color);
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background-color 0.3s ease, border-color 0.3s ease,
          box-shadow 0.3s ease;
      }

      #game-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 100;
        border-radius: 12px;
        text-align: center;
      }

      /* Base styling for all interactive buttons */
      .game-button {
        padding: 0.25rem 0.75rem;
        font-size: 1.1rem;
        font-weight: bold;
        background-color: var(--button-bg);
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.1s ease,
          box-shadow 0.3s ease;
        box-shadow: 0 3px 10px var(--button-shadow);
        margin: 0 5px;
      }

      /* Specific styling for the large start button in the overlay */
      #game-overlay-start-button {
        padding: 1rem 2.5rem;
        font-size: 1.5rem;
        box-shadow: 0 5px 15px var(--button-shadow);
        margin: 10px;
      }

      .game-button:hover {
        background-color: var(--button-hover-bg);
        transform: translateY(-2px);
      }

      .game-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 8px var(--button-shadow);
      }

      #game-stats {
        display: flex;
        flex-direction: column; /* Column layout for stats bar content */
        justify-content: center;
        align-items: center;
        width: 90vw; /* Default width for mobile */
        max-width: 1200px; /* Max width for mobile */
        background-color: var(--bg-secondary);
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 5px 10px var(--card-shadow);
        border: 1px solid var(--border-color);
        gap: 15px; /* Spacing between rows */
        font-size: 1.25rem;
        font-weight: bold;
        transition: background-color 0.3s ease, border-color 0.3s ease,
          box-shadow 0.3s ease, color 0.3s ease;
        flex-shrink: 0; /* Prevents stats bar from shrinking */
      }

      /* Each row within the stats bar */
      .stats-row {
        display: flex;
        justify-content: center; /* Center content within the row */
        align-items: center;
        width: 100%; /* Take full width of parent column */
        flex-wrap: wrap; /* Allow items to wrap within the row if needed */
        gap: 10px; /* Spacing between items in a row */
      }

      #hearts-container {
        display: flex;
        flex-wrap: wrap; /* Allow hearts to wrap to the next line */
        justify-content: center; /* Center hearts if they wrap */
        gap: 4px;
        font-size: 1.5rem;
        line-height: 1;
        flex-shrink: 1;
      }

      .card {
        position: absolute;
        width: 10vw;
        height: calc(10vw * 7 / 5);
        min-width: 80px;
        min-height: calc(80px * 7 / 5);
        max-width: 150px;
        max-height: calc(150px * 7 / 5);
        background-color: var(--card-bg-color);
        background-size: cover;
        background-position: center;
        border: none; /* Default no border */
        box-shadow: 0 4px 8px var(--card-shadow);
        opacity: 1; /* Start fully visible */
        z-index: 10;
        border-top-left-radius: 0;
        border-top-right-radius: 0;
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        /* Default quick transition for completion/hit effect */
        transition: opacity 0.3s ease-out, transform 0.3s ease,
          border-radius 0.2s ease, background-color 0.3s ease,
          box-shadow 0.3s ease;
      }

      /* Visual feedback: Card hit effect */
      .card.hit-effect {
        transform: scale(1.05);
        transition: transform 0.1s ease-out;
      }

      /* Class for cards that are fading out over their lifetime */
      .card.timed-fade-active {
        opacity: 0; /* Target opacity for timed fade */
        /* Dynamic transition duration set by JS for card lifetime + 0.5s */
        transition: opacity calc(var(--card-lifetime-seconds) + 0.5s) linear,
          transform 0.3s ease, border-radius 0.2s ease,
          background-color 0.3s ease, box-shadow 0.3s ease;
      }

      /* Special Card Styling - only glow */
      .card.special-card {
        box-shadow: 0 0 15px 5px var(--special-card-glow); /* Glowing effect */
      }

      /* Boss Card Styling - only glow */
      .card.boss-card {
        box-shadow: 0 0 20px 8px var(--boss-card-glow); /* Stronger, red glowing effect */
        animation: pulse 1.5s infinite alternate; /* Optional: pulsating animation */
      }

      @keyframes pulse {
        from {
          transform: scale(1);
          box-shadow: 0 0 20px 8px var(--boss-card-glow);
        }
        to {
          transform: scale(1.02);
          box-shadow: 0 0 25px 10px var(--boss-card-glow);
        }
      }

      .corner {
        position: absolute;
        width: 30px;
        height: 30px;
        background-color: transparent;
        border: none;
        cursor: pointer;
        z-index: 15;
      }

      /* Specific corner positions */
      .corner.top-left {
        top: -1px;
        left: -1px;
      }
      .corner.top-right {
        top: -1px;
        right: -1px;
      }
      .corner.bottom-left {
        bottom: -1px;
        left: -1px;
      }
      .corner.bottom-right {
        bottom: -1px;
        right: -1px;
      }

      #game-message {
        font-size: 2rem;
        font-weight: bold;
        color: var(--game-over-text);
        margin-bottom: 20px;
        display: none;
        transition: color 0.3s ease;
      }

      /* Styling for the start button when it's in the stats bar */
      #stats-start-button-container {
        display: none; /* Hidden by default, shown when needed */
      }

      /* Visual feedback: Level up animation */
      #level-display.level-up-animation {
        transform: scale(1.2);
        color: var(--level-up-color);
        transition: all 0.3s ease-out;
      }

      /* Toggle Switch Styles */
      .switch-container {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
        font-weight: normal;
        flex-shrink: 0;
        color: var(--text-color);
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 40px;
        height: 24px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--switch-bg-off);
        transition: 0.4s;
        border-radius: 24px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
      }

      input:checked + .slider {
        background-color: var(--switch-bg-on);
      }

      input:focus + .slider {
        box-shadow: 0 0 1px var(--switch-bg-on);
      }

      input:checked + .slider:before {
        transform: translateX(16px);
      }

      /* Emoji Icon styling */
      .emoji-icon {
        font-size: 1.5rem;
        line-height: 1;
        color: var(--emoji-color);
        transition: color 0.3s ease;
      }

      /* Sound Emojis */
      .emoji-icon.sound-on-emoji {
        display: none;
      }
      .emoji-icon.sound-off-emoji {
        display: inline-block;
      }
      #sound-toggle:checked ~ .sound-on-emoji {
        display: inline-block;
      }
      #sound-toggle:not(:checked) ~ .sound-on-emoji {
        display: none;
      }
      #sound-toggle:checked ~ .sound-off-emoji {
        display: none;
      }
      #sound-toggle:not(:checked) ~ .sound-off-emoji {
        display: inline-block;
      }

      /* Theme Emojis */
      .emoji-icon.moon-emoji {
        display: inline-block;
      }
      .emoji-icon.sun-emoji {
        display: none;
      }
      body.light-mode .emoji-icon.moon-emoji {
        display: none;
      }
      body.light-mode .emoji-icon.sun-emoji {
        display: inline-block;
      }

      /* Social Links Container */
      #social-links-container {
        display: flex;
        gap: 20px;
        margin-top: 20px;
        display: none;
      }

      .social-link {
        display: block;
        color: var(--social-icon-color);
        transition: color 0.2s ease, transform 0.1s ease;
      }

      .social-link:hover {
        color: var(--social-icon-hover);
        transform: translateY(-3px);
      }

      .social-icon {
        width: 32px;
        height: 32px;
        fill: currentColor;
      }

      /* --- Particle Animation Styles --- */
      .completion-particle {
        position: absolute;
        border-radius: 50%;
        opacity: 1; /* Start visible */
        /* Initial transform: centered and full size */
        transform: translate(-50%, -50%) scale(1);
        transition: transform 0.8s ease-out, opacity 0.8s ease-out; /* Animation duration */
        z-index: 20; /* Ensure particles are above cards */
      }

      /* Final state of the particle animation */
      .completion-particle.burst {
        opacity: 0; /* Fade out */
        /* Move outwards by --particle-end-x/y and scale down */
        transform: translate(
            calc(-50% + var(--particle-end-x, 0px)),
            calc(-50% + var(--particle-end-y, 0px))
          )
          scale(0);
      }

      /* --- DESKTOP / WIDE SCREEN LAYOUT --- */
      @media (min-width: 1024px) {
        /* Applies for screens wider than 1024px */
        body {
          flex-direction: column; /* Keep body as column, but center its content */
          justify-content: center; /* Center the whole content block vertically */
          padding: 20px; /* Maintain padding */
        }

        #game-title {
          margin-bottom: 30px; /* Keep margin below title */
        }

        #main-game-area {
          flex-direction: row; /* Stats and game side-by-side */
          justify-content: center; /* Center the row horizontally */
          align-items: stretch; /* Stretch children (stats, game container) to fill height */
          flex-grow: 1; /* Allow main game area to grow vertically */
          max-width: 100%; /* Allow it to take full width */
          gap: 30px; /* Space between stats and game area */

          min-height: 0; /* Ensure this flex item (main-game-area) can shrink if necessary */
        }

        #game-stats {
          width: 300px; /* Fixed width for the stats sidebar */
          margin-bottom: 0; /* No bottom margin when side-by-side */
          height: auto; /* Will stretch due to align-items: stretch on parent */
          padding: 20px; /* Adjust padding for sidebar look */
          box-shadow: 0 5px 15px var(--card-shadow); /* More prominent shadow for sidebar */
          min-height: 0; /* Ensure this flex item (main-game-area) can shrink if necessary */
          overflow-y: auto; /* If stats itself could be very long */
        }

        #game-container {
          width: auto; /* Let flex-grow handle width */
          flex-grow: 1; /* Take remaining horizontal space */
          height: auto; /* Will be constrained by max-height and aspect-ratio */
          aspect-ratio: 4 / 3; /* Maintain a 4:3 aspect ratio for gameplay area */
          max-width: 900px; /* Prevent game area from becoming too wide */
          min-height: 0; /* Add this to game-container */
          overflow: hidden; /* Keep this to hide cards outside */
        }

        /* Adjust font sizes for larger screens if desired */
        #game-stats {
          font-size: 1.1rem;
        }
        .game-button {
          font-size: 1rem;
          padding: 0.6rem 1.2rem;
        }
        .emoji-icon {
          font-size: 1.2rem;
        }
      }

      /* Mobile specific adjustments (already mostly good, but ensure no conflicts) */
      @media (max-width: 767px) {
        #game-title {
          font-size: 2rem;
          margin-bottom: 20px;
        }

        #game-stats {
          gap: 10px;
          font-size: 1rem;
        }

        .stats-row {
          gap: 5px;
        }

        .card {
          width: 15vw;
          height: calc(15vw * 7 / 5);
          min-width: 70px;
          min-height: calc(70px * 7 / 5);
        }

        .corner {
          width: 25px;
          height: 25px;
        }

        .game-button {
          padding: 0.4rem 1rem;
          font-size: 1.2rem;
        }

        #game-message {
          font-size: 1.5rem;
        }

        .switch-container {
          font-size: 0.8rem;
        }

        #social-links-container {
          gap: 15px;
        }
        .social-icon {
          width: 28px;
          height: 28px;
        }
      }
    </style>
  </head>
  <body>
    <h1 id="game-title"></h1>

    <div id="main-game-area">
      <div id="game-stats" class="rounded-lg">
        <div class="stats-row" id="dev-start-level-container">
          <label
            for="start-level-input"
            class="text-sm font-semibold text-gray-400"
            >Start Level (Dev):</label
          >
          <input
            type="number"
            id="start-level-input"
            value="1"
            min="1"
            class="w-20 p-1 rounded bg-gray-700 text-white border border-gray-600 text-center"
          />
        </div>
        <div class="stats-row">
          <button id="upload-button" class="game-button">Load cards</button>
          <input
            type="file"
            id="image-upload"
            accept="image/*"
            multiple
            class="hidden"
          />
        </div>

        <div class="stats-row">
          <div id="score-display">Score: 0</div>
          <div id="high-score-display">High Score: 0</div>
          <div id="stats-start-button-container">
            <button id="stats-start-button" class="game-button">
              Play Again
            </button>
            <button id="continue-game-button" class="game-button hidden">
              Continue Game
            </button>
          </div>
        </div>

        <div class="stats-row">
          <div id="hearts-container"></div>
        </div>

        <div class="stats-row">
          <div id="level-display">Level: 1</div>
        </div>

        <div class="stats-row">
          <div class="switch-container">
            <span class="emoji-icon sound-on-emoji">üîä</span>
            <span class="emoji-icon sound-off-emoji">üîá</span>
            <label class="switch">
              <input type="checkbox" id="sound-toggle" />
              <span class="slider"></span>
            </label>
          </div>
          <div class="switch-container">
            <div class="theme-toggle-icons">
              <span class="emoji-icon moon-emoji">üåô</span>
              <span class="emoji-icon sun-emoji">‚òÄÔ∏è</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="theme-toggle" />
              <span class="slider"></span>
            </label>
          </div>
        </div>
      </div>

      <div id="game-container">
        <div id="game-overlay">
          <div id="game-message"></div>
          <div id="social-links-container"></div>
          <button id="game-overlay-start-button" class="game-button">
            Start Game
          </button>
        </div>
      </div>
    </div>

    <script>
      // --- Game State Variables ---
      let score = 0;
      let lives = 10;
      let level = 1;
      let gameActive = false;
      let highScore = 0;
      let soundEnabled = true; // Default sound state
      let currentTheme = "dark"; // Default theme state
      let completionStreak = 0; // Tracks consecutive card completions
      let specialCardSpawnedThisLevel = false; // Flag to ensure only one special card per level
      let isBossLevel = false; // Flag to indicate if current level is a boss level

      // Intervals and timeouts
      let gameInterval; // For level progression
      let cardSpawnInterval; // For regular card spawning
      let bossMoveInterval; // For boss card movement

      const LEVEL_DURATION = 10000; // Level timer reduced to 10 seconds (10000 ms)
      let currentSpawnDelay = 2000; // Initial regular card spawn delay
      let cardLifetime = 5000; // Base regular card lifetime in ms

      // Boss Card specific constants
      const BOSS_CLICKS_PER_CORNER = 2; // Reduced to 2 clicks per corner
      const BOSS_COMPLETION_BONUS = 10;
      const BOSS_EXPIRATION_PENALTY = 10;
      const BOSS_LIFETIME_BASE = 15000; // Base lifetime for boss card
      const BOSS_LIFETIME_PER_LEVEL_BONUS = 1000; // Extra lifetime per level for boss card
      const BOSS_INITIAL_VELOCITY = 1.2; // Initial movement speed for boss card
      const BOSS_VELOCITY_PER_LEVEL_BONUS = 0.3; // Speed increase per level for boss card

      // Card management
      let cardIdCounter = 0;
      const activeCards = {}; // Stores all active cards by ID
      let bossCardElement = null; // Reference to the current boss card DOM element
      let bossCardVelocity = { x: 0, y: 0 };
      let bossCardDirection = { x: 1, y: 1 };

      // Image upload
      const uploadedImages = [];

      // --- DOM Elements ---
      const gameTitleElement = document.getElementById("game-title");
      const gameContainer = document.getElementById("game-container");
      const gameOverlay = document.getElementById("game-overlay");
      const gameOverlayStartButton = document.getElementById(
        "game-overlay-start-button"
      );
      const statsStartButtonContainer = document.getElementById(
        "stats-start-button-container"
      );
      const statsStartButton = document.getElementById("stats-start-button");
      const uploadButton = document.getElementById("upload-button");
      const imageUploadInput = document.getElementById("image-upload");
      const scoreDisplay = document.getElementById("score-display");
      const highScoreDisplay = document.getElementById("high-score-display");
      const heartsContainer = document.getElementById("hearts-container");
      const levelDisplay = document.getElementById("level-display");
      const gameMessage = document.getElementById("game-message");
      const soundToggle = document.getElementById("sound-toggle");
      const themeToggle = document.getElementById("theme-toggle");
      const soundOnEmoji = document.querySelector(".sound-on-emoji");
      const soundOffEmoji = document.querySelector(".sound-off-emoji");
      const moonEmoji = document.querySelector(".moon-emoji");
      const sunEmoji = document.querySelector(".sun-emoji");
      const socialLinksContainer = document.getElementById(
        "social-links-container"
      );
      const continueGameButton = document.getElementById(
        "continue-game-button"
      );
      // --- START TESTING/DEVELOPMENT FEATURE: SET STARTING LEVEL ---
      const startLevelInput = document.getElementById("start-level-input");
      // --- END TESTING/DEVELOPMENT FEATURE ---

      // List of possible game titles
      const gameTitles = [
        "Round Rush",
        "Corner Cruncher",
        "Clip the Corner",
        "Snip Snap!",
        "Trim & Tap!",
        "Click, Click, Click!",
        "Kadomaru Frenzy",
        "Curve Cutter",
        "Round 'Em Up!",
        "Card Chopper",
      ];

      // --- Tone.js Sound Effects ---
      let clickSynth,
        completeSynth,
        loseLifeSynth,
        levelUpSynth,
        gameOverSynth,
        bossIntroSynth;

      /**
       * Initializes Tone.js synths. This should be called after a user interaction
       * to ensure audio context is allowed to start.
       */
      function initializeAudio() {
        if (Tone.context.state !== "running") {
          Tone.start()
            .then(() => {
              console.log("Audio context started.");
            })
            .catch((e) => console.error("Failed to start audio context:", e));
        }
        // Attempt to resume context in case it was suspended (common on mobile)
        if (Tone.context.state === "suspended") {
          Tone.context
            .resume()
            .then(() => {
              console.log("Audio context resumed.");
            })
            .catch((e) => console.error("Failed to resume audio context:", e));
        }

        if (!clickSynth) {
          // Only create synths once
          // Click sound: short, high-pitched, slightly longer decay
          clickSynth = new Tone.Synth({
            oscillator: { type: "sine" },
            envelope: {
              attack: 0.01,
              decay: 0.1,
              sustain: 0.01,
              release: 0.15,
            },
          }).toDestination();

          // Card complete sound: slightly longer, harmonious, different chord
          completeSynth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" },
            envelope: {
              attack: 0.02,
              decay: 0.15,
              sustain: 0.05,
              release: 0.25,
            },
          }).toDestination();

          // Lose life sound: low, dissonant
          loseLifeSynth = new Tone.Synth({
            oscillator: { type: "sawtooth" },
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.01, release: 0.3 },
          }).toDestination();

          // Level up sound: ascending, pleasant
          levelUpSynth = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: {
              attack: 0.02,
              decay: 0.1,
              sustain: 0.05,
              release: 0.15,
            },
          }).toDestination();

          // Game over sound: sustained, ominous
          gameOverSynth = new Tone.Synth({
            oscillator: { type: "fmsine", modulationIndex: 3, detune: -1200 },
            envelope: { attack: 0.05, decay: 0.5, sustain: 0.1, release: 1 },
          }).toDestination();

          // Boss Intro sound: deep, impactful
          bossIntroSynth = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 8,
            envelope: {
              attack: 0.001,
              decay: 0.4,
              sustain: 0.01,
              release: 1.4,
              attackCurve: "exponential",
            },
          }).toDestination();
        }

        console.log("Audio initialized.");
      }

      /**
       * Plays a specific sound effect.
       * @param {string} type - The type of sound to play ('click', 'complete', 'loseLife', 'levelUp', 'gameOver', 'bossIntro').
       */
      function playSound(type) {
        if (!soundEnabled || Tone.context.state !== "running") {
          console.log(
            `Sound disabled or audio context not running. Cannot play ${type} sound. State: ${Tone.context.state}`
          ); // Added state
          return;
        }
        try {
          console.log(`Attempting to play ${type} sound.`); // Added log for debugging
          switch (type) {
            case "click":
              clickSynth.triggerAttackRelease("G5", "16n"); // Slightly higher pitch, short duration
              break;
            case "complete":
              completeSynth.triggerAttackRelease(["D4", "F#4", "A4"], "4n"); // Different harmonious chord
              break;
            case "loseLife":
              loseLifeSynth.triggerAttackRelease("F#3", "4n");
              break;
            case "levelUp":
              levelUpSynth.triggerAttackRelease("C5", "16n", Tone.now());
              levelUpSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.1);
              levelUpSynth.triggerAttackRelease("G5", "16n", Tone.now() + 0.2);
              break;
            case "gameOver":
              gameOverSynth.triggerAttackRelease("C3", "2n");
              break;
            case "bossIntro":
              bossIntroSynth.triggerAttackRelease("C2", "2n");
              break;
          }
        } catch (e) {
          console.error("Error playing sound:", e);
        }
      }

      /**
       * Loads the sound preference from localStorage.
       */
      function loadSoundPreference() {
        const storedSound = localStorage.getItem("soundEnabled");
        if (storedSound !== null) {
          soundEnabled = storedSound === "true"; // Checked means sound ON
        }
        soundToggle.checked = soundEnabled; // Update switch UI
        updateSoundEmojiVisibility(); // Update icon visibility
      }

      /**
       * Saves the sound preference to localStorage.
       */
      function saveSoundPreference() {
        localStorage.setItem("soundEnabled", soundEnabled);
      }

      /**
       * Toggles the sound on/off.
       */
      function toggleSound() {
        soundEnabled = soundToggle.checked; // Directly use checked state
        saveSoundPreference();
        updateSoundEmojiVisibility(); // Update icon visibility
        console.log("Sound Enabled:", soundEnabled);
      }

      /**
       * Updates the visibility of speaker emojis based on soundEnabled state.
       */
      function updateSoundEmojiVisibility() {
        if (soundEnabled) {
          soundOnEmoji.style.display = "inline-block";
          soundOffEmoji.style.display = "none";
        } else {
          soundOnEmoji.style.display = "none";
          soundOffEmoji.style.display = "inline-block";
        }
      }

      /**
       * Loads the theme preference from localStorage.
       */
      function loadThemePreference() {
        const storedTheme = localStorage.getItem("currentTheme");
        if (storedTheme) {
          currentTheme = storedTheme;
        } else {
          currentTheme = "dark"; // Default to dark if no preference
        }
        applyTheme(currentTheme);
        themeToggle.checked = currentTheme === "light"; // Checked means light mode ON
        updateThemeEmojiVisibility(); // Update icon visibility
      }

      /**
       * Saves the theme preference to localStorage.
       */
      function saveThemePreference() {
        localStorage.setItem("currentTheme", currentTheme);
      }

      /**
       * Applies the specified theme to the body.
       * @param {string} theme - 'dark' or 'light'.
       */
      function applyTheme(theme) {
        if (theme === "light") {
          document.body.classList.add("light-mode");
        } else {
          document.body.classList.remove("light-mode");
        }
        updateThemeEmojiVisibility(); // Update icon visibility when theme changes
      }

      /**
       * Toggles the theme between dark and light.
       */
      function toggleTheme() {
        currentTheme = themeToggle.checked ? "light" : "dark"; // Directly use checked state
        applyTheme(currentTheme);
        saveSoundPreference();
        console.log("Current Theme:", currentTheme);
      }

      /**
       * Updates the visibility of moon/sun emojis based on currentTheme state.
       */
      function updateThemeEmojiVisibility() {
        if (currentTheme === "light") {
          moonEmoji.style.display = "none";
          sunEmoji.style.display = "inline-block";
        } else {
          moonEmoji.style.display = "inline-block";
          sunEmoji.style.display = "none";
        }
      }

      /**
       * Sets a random game title from the predefined list.
       */
      function setRandomGameTitle() {
        const randomIndex = Math.floor(Math.random() * gameTitles.length);
        gameTitleElement.textContent = gameTitles[randomIndex];
      }

      /**
       * Loads the high score from localStorage and updates the display.
       */
      function loadHighScore() {
        const storedHighScore = localStorage.getItem("highScore");
        if (storedHighScore) {
          highScore = parseInt(storedHighScore, 10);
        } else {
          highScore = 0;
        }
        highScoreDisplay.textContent = `High Score: ${highScore}`;
      }

      /**
       * Initializes and starts the game from a specific level.
       * Used for initial start and continuing after Level 10.
       * @param {number} startLevelOverride - The level to start the game from. If 1, it's a new game. If >1, it's a continuation.
       */
      function startGameFromLevel(startLevelOverride) {
        initializeAudio(); // Initialize audio context and synths on first user interaction
        setRandomGameTitle(); // Set new title every time game starts

        // --- START TESTING/DEVELOPMENT FEATURE: SET STARTING LEVEL ---
        let initialLevel = startLevelOverride;
        if (startLevelOverride === 1) {
          // Only use input for new games (Start Game / Play Again)
          const inputLevel = parseInt(startLevelInput.value, 10);
          if (!isNaN(inputLevel) && inputLevel >= 1) {
            initialLevel = inputLevel;
          }
        }
        level = initialLevel;
        // --- END TESTING/DEVELOPMENT FEATURE ---

        // Reset score and lives ONLY if it's a new game (starting from level 1)
        // If continuing from level 11 after celebration, score and lives should already be correct.
        if (startLevelOverride === 1) {
          // This condition means it's a fresh start
          score = 0;
          lives = 10;
          console.log("Starting NEW game: score and lives reset.");
        } else {
          console.log("Continuing game: score and lives preserved.");
        }

        completionStreak = 0; // Reset streak on new game or continuation
        specialCardSpawnedThisLevel = false; // Reset special card flag
        isBossLevel = false; // Reset boss level flag

        // Clear any existing intervals from previous games
        clearInterval(gameInterval);
        clearInterval(cardSpawnInterval);
        clearInterval(bossMoveInterval); // Ensure boss movement is stopped

        // Clear any existing cards without penalty
        clearGame(true); // Pass true to skip penalties

        // Update difficulty parameters based on the new level
        updateDifficultyParameters();

        // Update UI
        scoreDisplay.textContent = `Score: ${score}`;
        updateLivesDisplay(); // Update lives display with hearts
        levelDisplay.textContent = `Level: ${level}`;
        gameOverlay.style.display = "none"; // Hide the overlay
        gameMessage.style.display = "none";
        gameOverlayStartButton.style.display = "none"; // Hide default start button
        statsStartButtonContainer.style.display = "none"; // Hide stats bar play again button
        socialLinksContainer.style.display = "none"; // Hide social links
        continueGameButton.classList.add("hidden"); // Hide continue button

        gameActive = true; // Set game to active AFTER setup

        // Start game intervals
        gameInterval = setInterval(levelUp, LEVEL_DURATION);
        cardSpawnInterval = setInterval(spawnCard, currentSpawnDelay);

        console.log(`Game Started from Level ${level}!`);
      }

      /**
       * Updates difficulty parameters (spawn delay, card lifetime) based on the current level.
       */
      function updateDifficultyParameters() {
        // Reset to base values for calculation, then apply level progression
        currentSpawnDelay = 2000;
        cardLifetime = 5000;

        for (let i = 1; i < level; i++) {
          // Loop up to (current level - 1)
          if (i % 3 !== 0) {
            // Only apply for regular levels
            currentSpawnDelay = Math.max(400, currentSpawnDelay * 0.9);
            cardLifetime = Math.max(1500, cardLifetime * 0.9);
          }
        }
        console.log(
          `Difficulty parameters updated for Level ${level}: Spawn Delay: ${currentSpawnDelay}ms, Card Lifetime: ${cardLifetime}ms`
        );
      }

      /**
       * Ends the game, clears intervals, and displays final score.
       */
      function endGame() {
        gameActive = false;
        clearGame(true); // Clear all cards and intervals without penalty
        playSound("gameOver"); // Play game over sound

        // Update high score if current score is higher
        if (score > highScore) {
          highScore = score;
          localStorage.setItem("highScore", highScore);
          loadHighScore(); // Update display
        }

        // Update game message with level and score
        gameMessage.textContent = `Game Over! You reached level ${level} with a total score of ${score}.`;
        gameMessage.style.display = "block";
        gameOverlay.style.display = "flex"; // Show overlay with message
        gameOverlayStartButton.style.display = "none"; // Ensure overlay button is hidden
        statsStartButtonContainer.style.display = "block"; // Show "Play Again" button in stats bar
        statsStartButton.textContent = "Play Again"; // Set text for stats bar button
        socialLinksContainer.style.display = "flex"; // Show social links
        continueGameButton.classList.add("hidden"); // Ensure continue button is hidden
        console.log("Game Over!");
      }

      /**
       * Reduces player's life and checks for game over.
       */
      function loseLife() {
        if (!gameActive) return;
        lives--;
        completionStreak = 0; // Reset streak on losing a life
        updateLivesDisplay(); // Update lives display
        playSound("loseLife"); // Play lose life sound
        console.log(`Lost a life! Remaining: ${lives}`);
        if (lives <= 0) {
          endGame();
        }
      }

      /**
       * Updates the visual display of lives using heart emojis.
       */
      function updateLivesDisplay() {
        heartsContainer.innerHTML = ""; // Clear existing hearts
        for (let i = 0; i < lives; i++) {
          const heart = document.createElement("span");
          heart.textContent = "‚ù§Ô∏è"; // Red heart emoji
          heartsContainer.appendChild(heart);
        }
      }

      /**
       * Clears all active cards and game intervals.
       * @param {boolean} skipPenalty - If true, cards are removed without triggering expiration penalties.
       */
      function clearGame(skipPenalty = false) {
        // Get a list of active card IDs to iterate safely
        const cardIdsToClear = Object.keys(activeCards);

        // Clear all active cards from the DOM and activeCards object
        cardIdsToClear.forEach((cardId) => {
          const card = activeCards[cardId];
          if (card) {
            // Call removeCard with completedByPlayer=false and the skipPenalty flag
            // This ensures penalties are skipped if skipPenalty is true,
            // otherwise normal expiration penalties apply.
            removeCard(cardId, false, skipPenalty);
          }
        });

        // Clear main game intervals
        clearInterval(gameInterval);
        clearInterval(cardSpawnInterval);
        clearInterval(bossMoveInterval); // Stop boss movement interval
        bossCardElement = null; // Clear boss card reference
        console.log(`Game area cleared. Skip penalty: ${skipPenalty}`);
      }

      /**
       * Advances the game to the next level, increasing difficulty, or starts a boss level.
       */
      function levelUp() {
        if (!gameActive) return;

        // Check for Level 10 completion first
        if (level === 10) {
          gameActive = false; // Pause game
          clearGame(true); // Clear all cards without penalty for celebration

          gameMessage.textContent =
            "Congratulations! You've mastered the corners!";
          gameMessage.style.display = "block";
          gameOverlay.style.display = "flex";
          gameOverlayStartButton.style.display = "none"; // Hide default start button
          socialLinksContainer.style.display = "none"; // Hide social links

          statsStartButtonContainer.style.display = "block"; // Show the container
          statsStartButton.classList.add("hidden"); // Hide Play Again
          continueGameButton.classList.remove("hidden"); // Show Continue Game

          // Trigger big burst at the center of the game container
          const dummyElement = document.createElement("div");
          dummyElement.style.position = "absolute";
          dummyElement.style.left = "50%";
          dummyElement.style.top = "50%";
          dummyElement.style.width = "1px";
          dummyElement.style.height = "1px";
          gameContainer.appendChild(dummyElement);
          createCompletionAnimation(dummyElement, true); // True for big burst
          setTimeout(() => dummyElement.remove(), 1000); // Remove dummy after burst

          level++; // Increment level to 11 for continuation
          console.log(
            "Level 10 completed! Celebration! Next level will be " + level
          );
          return; // Stop further level progression until user clicks continue
        }

        level++; // Increment level for regular progression
        levelDisplay.textContent = `Level: ${level}`;
        playSound("levelUp");

        if (level % 3 === 0) {
          // Every 3rd level is a Boss Level
          isBossLevel = true;
          clearInterval(cardSpawnInterval); // Stop regular card spawning
          clearInterval(gameInterval); // Pause level timer
          clearGame(true); // Clear any remaining cards without penalty for boss intro

          gameMessage.textContent = "BOSS LEVEL!";
          gameMessage.style.display = "block";
          gameOverlay.style.display = "flex";
          gameOverlayStartButton.style.display = "none";
          socialLinksContainer.style.display = "none";
          statsStartButtonContainer.style.display = "none"; // Hide stats bar buttons during boss intro
          continueGameButton.classList.add("hidden"); // Ensure continue button is hidden

          // Play boss intro sound
          playSound("bossIntro");

          setTimeout(() => {
            gameOverlay.style.display = "none";
            spawnBossCard(); // Spawn the single boss card
          }, 2000); // Show "BOSS LEVEL!" message for 2 seconds
        } else {
          // Regular Level
          isBossLevel = false;
          specialCardSpawnedThisLevel = false; // Reset special card flag for new regular level
          currentSpawnDelay = Math.max(400, currentSpawnDelay * 0.9); // Spawn delay multiplier changed to 0.9
          cardLifetime = Math.max(1500, cardLifetime * 0.9); // Min 1.5s card lifetime

          // Restart regular card spawning
          clearInterval(cardSpawnInterval);
          cardSpawnInterval = setInterval(spawnCard, currentSpawnDelay);

          // Restart level timer
          clearInterval(gameInterval);
          gameInterval = setInterval(levelUp, LEVEL_DURATION);
        }
        console.log(
          `Level Up! Current Level: ${level}, Spawn Delay: ${currentSpawnDelay}ms, Card Lifetime: ${cardLifetime}ms`
        );
      }

      /**
       * Spawns a new card on the screen, either a regular, special, or boss card.
       * @param {boolean} isBoss - True if this card should be a boss card.
       * @returns {string} The ID of the spawned card.
       */
      function spawnCard(isBoss = false) {
        if (!gameActive) return;

        const cardId = `card-${cardIdCounter++}`;
        const cardElement = document.createElement("div");
        cardElement.id = cardId;

        let cardData = {
          element: cardElement,
          cornersClicked: [], // Will be set based on card type
          timeout: null,
          isSpecial: false,
          isBoss: isBoss, // Store boss status
        };

        if (isBoss) {
          cardElement.className = "card boss-card";
          cardData.cornersClicked = new Array(4).fill(0); // Boss cards require multiple clicks per corner
          cardData.isSpecial = true; // Boss cards are also considered special for particle effects
          // Boss card expiration will be handled by its specific timeout in spawnBossCard
        } else {
          cardElement.className = "card";
          cardData.cornersClicked = [false, false, false, false]; // Regular cards are boolean clicks

          // Determine if this is a regular special card (only if not a boss level and not already spawned this level)
          if (
            !isBossLevel &&
            !specialCardSpawnedThisLevel &&
            Math.random() < 0.3
          ) {
            // 30% chance for a special card
            cardData.isSpecial = true;
            specialCardSpawnedThisLevel = true;
            cardElement.classList.add("special-card");
            console.log(`Regular special card ${cardId} spawned!`);
          }
          // Set dynamic CSS variable for regular card's fade-out duration
          cardElement.style.setProperty(
            "--card-lifetime-seconds",
            `${cardLifetime / 1000}s`
          );
          // Trigger the timed fade-out after a small delay to ensure initial render
          setTimeout(() => {
            cardElement.classList.add("timed-fade-active");
          }, 50);

          // Regular card timeout for expiration
          cardData.timeout = setTimeout(() => {
            // When a regular card expires, it's not "completedByPlayer" and not "forceRemoveNoPenalty"
            removeCard(cardId, false, false); // Pass false for forceRemoveNoPenalty
          }, cardLifetime + 500); // Adjusted timeout for removal
        }

        // Set background image
        if (uploadedImages.length > 0) {
          const randomIndex = Math.floor(Math.random() * uploadedImages.length);
          cardElement.style.backgroundImage = `url('${uploadedImages[randomIndex]}')`;
          cardElement.style.backgroundColor = "transparent";
        } else {
          cardElement.style.backgroundImage = "none";
          cardElement.style.backgroundColor = "var(--card-bg-color)";
        }

        // Calculate random position within game container
        const containerRect = gameContainer.getBoundingClientRect();
        const cardApproxWidth = 100; // Approximate initial width for positioning
        const cardApproxHeight = (cardApproxWidth * 7) / 5; // Approximate initial height
        let randomX = Math.random() * (containerRect.width - cardApproxWidth);
        let randomY = Math.random() * (containerRect.height - cardApproxHeight);
        randomX = Math.max(
          0,
          Math.min(randomX, containerRect.width - cardApproxWidth)
        );
        randomY = Math.max(
          0,
          Math.min(randomY, containerRect.height - cardApproxHeight)
        );
        cardElement.style.left = `${randomX}px`;
        cardElement.style.top = `${randomY}px`;

        // Create 4 corner elements (invisible hitboxes)
        const corners = [
          "top-left",
          "top-right",
          "bottom-left",
          "bottom-right",
        ];
        corners.forEach((pos, index) => {
          const cornerElement = document.createElement("div");
          cornerElement.className = `corner ${pos}`;
          cornerElement.addEventListener("click", (event) => {
            event.stopPropagation();
            handleCornerClick(cardId, index, cornerElement);
          });
          cardElement.appendChild(cornerElement);
        });

        gameContainer.appendChild(cardElement);
        activeCards[cardId] = cardData; // Store card data
        console.log(
          `Card ${cardId} spawned! Is Boss: ${isBoss}, Is Special: ${cardData.isSpecial}`
        );
        return cardId; // Return the ID for boss card tracking
      }

      /**
       * Spawns the single boss card for a boss level.
       */
      function spawnBossCard() {
        const bossCardId = spawnCard(true); // Call spawnCard with isBoss = true
        const bossCard = activeCards[bossCardId];
        if (bossCard) {
          bossCardElement = bossCard.element; // Store reference to the boss card DOM element

          // Boss speed increases with level
          // (Math.floor(level / 3) - 1) calculates how many boss levels have been completed before this one
          bossCardVelocity = {
            x:
              BOSS_INITIAL_VELOCITY +
              (Math.floor(level / 3) - 1) * BOSS_VELOCITY_PER_LEVEL_BONUS,
            y:
              BOSS_INITIAL_VELOCITY +
              (Math.floor(level / 3) - 1) * BOSS_VELOCITY_PER_LEVEL_BONUS,
          };
          // Random initial direction
          bossCardDirection = {
            x: Math.random() > 0.5 ? 1 : -1,
            y: Math.random() > 0.5 ? 1 : -1,
          };

          // Start boss movement
          clearInterval(bossMoveInterval); // Clear any old interval
          bossMoveInterval = setInterval(moveBossCard, 20); // Move every 20ms

          // Set a fixed lifetime for the boss card, after which it expires
          const currentBossLifetime =
            BOSS_LIFETIME_BASE +
            (Math.floor(level / 3) - 1) * BOSS_LIFETIME_PER_LEVEL_BONUS;
          bossCard.timeout = setTimeout(() => {
            removeCard(bossCardId, false, false); // Boss card expired, apply penalty
          }, currentBossLifetime);
        }
      }

      /**
       * Moves the boss card within the game container.
       */
      function moveBossCard() {
        if (!bossCardElement || !gameActive) return;

        const cardRect = bossCardElement.getBoundingClientRect();
        const containerRect = gameContainer.getBoundingClientRect();

        // Get current position relative to container
        // Use getComputedStyle to get current 'left' and 'top' values as numbers
        const currentLeft = parseFloat(getComputedStyle(bossCardElement).left);
        const currentTop = parseFloat(getComputedStyle(bossCardElement).top);

        let newX = currentLeft + bossCardVelocity.x * bossCardDirection.x;
        let newY = currentTop + bossCardVelocity.y * bossCardDirection.y;

        // Boundary checks and reverse direction
        if (newX + cardRect.width > containerRect.width || newX < 0) {
          bossCardDirection.x *= -1;
          // Clamp to boundary to prevent sticking
          newX = Math.max(
            0,
            Math.min(newX, containerRect.width - cardRect.width)
          );
        }
        if (newY + cardRect.height > containerRect.height || newY < 0) {
          bossCardDirection.y *= -1;
          // Clamp to boundary to prevent sticking
          newY = Math.max(
            0,
            Math.min(newY, containerRect.height - cardRect.height)
          );
        }

        bossCardElement.style.left = `${newX}px`;
        bossCardElement.style.top = `${newY}px`;
      }

      /**
       * Creates a particle burst animation at the center of a given element.
       * @param {HTMLElement} element - The element (card or dummy) at whose center the burst should occur.
       * @param {boolean} isBigBurst - True if this is a bonus streak burst or special/boss card completion, for larger animation.
       */
      function createCompletionAnimation(element, isBigBurst = false) {
        const numParticles = isBigBurst ? 30 : 15; // More particles for big burst
        const particleMinSize = isBigBurst ? 6 : 4; // Larger min size for big burst
        const particleMaxSize = isBigBurst ? 15 : 10; // Larger max size for big burst
        const burstDistance = isBigBurst ? 100 : 60; // Further burst for big burst

        const elementRect = element.getBoundingClientRect();
        const containerRect = gameContainer.getBoundingClientRect();

        // Calculate center of the element relative to the game container
        const centerX =
          elementRect.left - containerRect.left + elementRect.width / 2;
        const centerY =
          elementRect.top - containerRect.top + elementRect.height / 2;

        for (let i = 0; i < numParticles; i++) {
          const particle = document.createElement("div");
          particle.classList.add("completion-particle");

          // Set particle color based on bonus burst
          if (isBigBurst) {
            particle.style.backgroundColor = "var(--bonus-particle-color)";
          } else {
            particle.style.backgroundColor = "var(--particle-color)";
          }

          // Random size
          const size =
            Math.random() * (particleMaxSize - particleMinSize) +
            particleMinSize;
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;

          // Set initial position (centered on the element)
          particle.style.left = `${centerX}px`;
          particle.style.top = `${centerY}px`;

          // Calculate random angle and distance for burst
          const angle = Math.random() * Math.PI * 2; // Full circle (0 to 2*PI radians)
          const distance = Math.random() * burstDistance;

          // Calculate the final translation for the particle
          const deltaX = Math.cos(angle) * distance;
          const deltaY = Math.sin(angle) * distance;

          // Set CSS custom properties for the final translation
          particle.style.setProperty("--particle-end-x", `${deltaX}px`);
          particle.style.setProperty("--particle-end-y", `${deltaY}px`);

          gameContainer.appendChild(particle);

          // Trigger animation by adding the 'burst' class after a very short delay
          // This ensures the initial styles are applied before the transition starts
          setTimeout(() => {
            particle.classList.add("burst");
          }, 10);

          // Remove particle after animation completes
          setTimeout(() => {
            particle.remove();
          }, 800); // Matches CSS transition duration
        }
      }

      /**
       * Handles a click on a card corner.
       * @param {string} cardId - The ID of the card.
       * @param {number} cornerIndex - The index of the clicked corner (0-3).
       * @param {HTMLElement} cornerElement - The DOM element of the clicked corner.
       */
      function handleCornerClick(cardId, cornerIndex, cornerElement) {
        if (!gameActive) return;

        const card = activeCards[cardId];
        if (!card) return; // Card might have been removed already

        let allCornersCompleted = false;
        let isBigBurst = false;

        if (card.isBoss) {
          // For boss cards, cornersClicked stores click counts
          if (card.cornersClicked[cornerIndex] < BOSS_CLICKS_PER_CORNER) {
            card.cornersClicked[cornerIndex]++;
            score += 1; // Each click on a boss card corner gives 1 point
            scoreDisplay.textContent = `Score: ${score}`;
            playSound("click");

            // Apply border-radius when a corner reaches its required clicks
            if (card.cornersClicked[cornerIndex] === BOSS_CLICKS_PER_CORNER) {
              const borderClasses = [
                "rounded-tl-lg",
                "rounded-tr-lg",
                "rounded-bl-lg",
                "rounded-br-lg",
              ];
              card.element.classList.add(borderClasses[cornerIndex]);
            }

            // Check if ALL corners have reached their required clicks
            allCornersCompleted = card.cornersClicked.every(
              (count) => count === BOSS_CLICKS_PER_CORNER
            );
          }
        } else {
          // For regular cards, cornersClicked stores booleans
          if (!card.cornersClicked[cornerIndex]) {
            card.cornersClicked[cornerIndex] = true;
            score += 1;
            scoreDisplay.textContent = `Score: ${score}`;
            playSound("click");

            // Visual feedback: Card hit effect
            card.element.classList.add("hit-effect");
            setTimeout(() => {
              card.element.classList.remove("hit-effect");
            }, 100);

            // Apply border-radius to the main card element based on the clicked corner
            const borderClasses = [
              "rounded-tl-lg",
              "rounded-tr-lg",
              "rounded-bl-lg",
              "rounded-br-lg",
            ];
            card.element.classList.add(borderClasses[cornerIndex]);

            // Check if all corners of the card are clicked
            allCornersCompleted = card.cornersClicked.every(
              (clicked) => clicked
            );
          }
        }

        if (allCornersCompleted) {
          console.log(`Card ${cardId} completed!`);
          playSound("complete"); // Play card complete sound

          if (card.isBoss) {
            score += BOSS_COMPLETION_BONUS; // Bonus for boss card completion
            scoreDisplay.textContent = `Score: ${score}`;
            lives += Math.floor(level / 3); // Gain hearts based on current boss level
            updateLivesDisplay();
            isBigBurst = true; // Boss completion ALWAYS gets a big burst
            console.log(
              `Boss card defeated! +${BOSS_COMPLETION_BONUS} bonus points, +${Math.floor(
                level / 3
              )} heart(s)!`
            );
            createCompletionAnimation(card.element, isBigBurst); // Trigger particle animation
            removeCard(cardId, true); // Remove the completed boss card
            // Game progression will be handled by removeCard for boss
          } else {
            completionStreak++; // Increment streak for regular cards
            if (completionStreak % 4 === 0) {
              // Every 4th card completed
              score += 5; // Award bonus points
              scoreDisplay.textContent = `Score: ${score}`; // Update score display
              isBigBurst = true;
              console.log("Streak bonus! +5 points!");
            }

            if (card.isSpecial) {
              // Regular special card completed
              score += 3; // Bonus for special card completion
              scoreDisplay.textContent = `Score: ${score}`;
              isBigBurst = true; // Special cards also get a big burst
              console.log("Special card completed! +3 bonus points!");
            }
            createCompletionAnimation(card.element, isBigBurst); // Trigger particle animation, with big burst flag
            removeCard(cardId, true); // Remove the completed regular card
          }
        }
      }

      /**
       * Removes a card from the DOM and the activeCards tracking.
       * This function is called both when a card is completed and when it expires.
       * For completed cards, it triggers a quick fade-out.
       * For expired cards, they should have already faded via the timed-fade-active class.
       * @param {string} cardId - The ID of the card to remove.
       * @param {boolean} completedByPlayer - True if the card was completed by player.
       * @param {boolean} forceRemoveNoPenalty - True if card is being removed due to game state change (e.g., boss intro, level 10 celebration) and no penalty should apply.
       */
      function removeCard(
        cardId,
        completedByPlayer = false,
        forceRemoveNoPenalty = false
      ) {
        const card = activeCards[cardId];
        if (!card) return;

        clearTimeout(card.timeout); // Always clear the timeout for this card

        if (card.isBoss) {
          clearInterval(bossMoveInterval); // Stop boss movement
          bossCardElement = null; // Clear reference to the boss card element
          if (!completedByPlayer && !forceRemoveNoPenalty) {
            // Boss card expired and not a forced removal
            score -= BOSS_EXPIRATION_PENALTY;
            lives--; // Still lose 1 heart
            completionStreak = 0; // Reset streak
            updateLivesDisplay();
            playSound("loseLife");
            console.log(
              "Boss card expired! -" +
                BOSS_EXPIRATION_PENALTY +
                " points, -1 heart. Score: " +
                score
            );
            if (lives <= 0) {
              endGame();
            } else {
              isBossLevel = false; // End boss level state
              specialCardSpawnedThisLevel = false; // Reset for next level
              levelUp(); // Immediately advance to next regular level
            }
          } else if (completedByPlayer) {
            // Boss card completed by player
            // Score and streak already handled in handleCornerClick
            // Lives already handled in handleCornerClick (gained hearts)
            console.log("Boss card completed!");
            isBossLevel = false; // End boss level state
            specialCardSpawnedThisLevel = false; // Reset for next level
            levelUp(); // Immediately advance to next regular level
          }
          // Remove element visually with a quick fade for boss cards
          card.element.style.transition =
            "opacity 0.2s ease-out, transform 0.3s ease";
          card.element.style.opacity = "0";
          card.element.addEventListener(
            "transitionend",
            () => {
              if (card.element.parentNode) {
                card.element.remove();
              }
            },
            { once: true }
          );
        } else {
          // Regular card (including regular special cards)
          if (completedByPlayer) {
            // Card was completed, apply a quick fade-out animation
            card.element.classList.remove("timed-fade-active"); // Stop timed fade
            card.element.style.transition =
              "opacity 0.2s ease-out, transform 0.3s ease, border-radius 0.2s ease, background-color 0.3s ease, box-shadow 0.3s ease";
            card.element.style.opacity = "0"; // Trigger quick fade
            card.element.addEventListener(
              "transitionend",
              () => {
                if (card.element.parentNode) {
                  card.element.remove();
                }
              },
              { once: true }
            );
          } else if (!forceRemoveNoPenalty) {
            // Card expired naturally and not a forced removal
            // Card expired naturally (timed-fade-active already set opacity to 0)
            // Penalty logic for regular cards (including special cards)
            if (card.isSpecial) {
              // Regular special card expired
              score -= 6; // Penalize for special card expiry
              scoreDisplay.textContent = `Score: ${score}`;
              console.log("Special card expired! -6 points. Score: " + score);
              completionStreak = 0; // Reset streak
              playSound("loseLife");
            } else {
              // Regular card expired
              loseLife(); // Regular lose life (handles streak reset)
            }
            if (card.element.parentNode) {
              card.element.remove();
            }
          } else {
            // Card is being force removed without penalty
            if (card.element.parentNode) {
              card.element.remove();
            }
          }
        }
        delete activeCards[cardId]; // Remove from tracking object
      }

      // --- Event Listeners ---
      // Listen to both start buttons
      gameOverlayStartButton.addEventListener("click", () =>
        startGameFromLevel(1)
      ); // Start from level 1
      statsStartButton.addEventListener("click", () => startGameFromLevel(1)); // Start from level 1
      continueGameButton.addEventListener("click", () =>
        startGameFromLevel(level)
      ); // Continue from current level (which will be 11)

      // Event listener for the upload button
      uploadButton.addEventListener("click", () => {
        imageUploadInput.click(); // Programmatically click the hidden file input
      });

      // Event listener for when files are selected
      imageUploadInput.addEventListener("change", (event) => {
        const files = event.target.files;
        uploadedImages.length = 0; // Clear previous images

        if (files.length === 0) {
          console.log("No files selected.");
          uploadButton.textContent = "Load cards"; // Revert text if no files selected
          return;
        }

        // Limit to a maximum of 10 images
        const filesToProcess = Array.from(files).slice(0, 10);
        let loadedCount = 0;

        // Set initial text while loading
        uploadButton.textContent = `Loading ${filesToProcess.length} cards...`;

        if (filesToProcess.length === 0) {
          uploadButton.textContent = "Load cards";
          return;
        }

        filesToProcess.forEach((file) => {
          if (file.type.startsWith("image/")) {
            const reader = new FileReader();
            reader.onload = (e) => {
              uploadedImages.push(e.target.result);
              loadedCount++;
              // Update button text after each image is loaded, or once all are queued
              if (loadedCount === filesToProcess.length) {
                uploadButton.textContent = `${uploadedImages.length} cards loaded`;
              }
              console.log(`Image loaded: ${file.name}`);
            };
            reader.onerror = (error) => {
              console.error("Error reading file:", error);
              // Still update count even if some fail to load
              loadedCount++;
              if (loadedCount === filesToProcess.length) {
                uploadButton.textContent = `${uploadedImages.length} cards loaded`;
              }
            };
            reader.readAsDataURL(file);
          } else {
            console.warn(`Skipping non-image file: ${file.name}`);
            // Still update count even if some are skipped
            loadedCount++;
            if (loadedCount === filesToProcess.length) {
              uploadButton.textContent = `${uploadedImages.length} cards loaded`;
            }
          }
        });

        // This case handles if all selected files were invalid and skipped
        // It will be triggered if filesToProcess has items but none are valid images
        if (uploadedImages.length === 0 && filesToProcess.length > 0) {
          uploadButton.textContent = "0 cards loaded (invalid files)";
        }
        console.log(`Attempted to load ${filesToProcess.length} files.`);
      });

      // Sound and Theme Toggle Event Listeners
      soundToggle.addEventListener("change", toggleSound);
      themeToggle.addEventListener("change", toggleTheme);

      // Initial setup
      window.onload = () => {
        updateLivesDisplay(); // Initialize hearts display on load
        setRandomGameTitle(); // Set initial random game title on page load
        uploadButton.textContent = "Load cards"; // Set initial text for upload button
        loadHighScore(); // Load high score on page load
        loadSoundPreference(); // Load sound preference
        loadThemePreference(); // Load theme preference
        console.log("Window loaded. Ready to play!");
      };
    </script>
  </body>
</html>
